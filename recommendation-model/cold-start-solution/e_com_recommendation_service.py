# -*- coding: utf-8 -*-
"""E_Commerce_Recommendation_Service.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DlWDqx4stcErxTqk39WHBQ02OXzyz-Wp
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd

data = pd.read_csv('/content/drive/MyDrive/recommendation/multi-category-dataset-recommendation.csv')
df = data.dropna()

columns_to_keep = ['user_id', 'category_code', 'event_type', 'event_time', 'brand', 'price', 'age', 'gender', 'location']
df = data[columns_to_keep].copy()

split_category = df['category_code'].str.split('.', 1, expand=True)
df['category'] = split_category[0]
df['product_name'] = split_category[1]

df['age'].fillna(df['age'].mean(), inplace=True)

df['event_time'] = pd.to_datetime(df['event_time'], format='%Y-%m-%d %H:%M:%S %Z', utc=True)

print(df.head())

user_profiles = df.groupby('user_id').agg({
    'age': 'mean',
    'gender': 'first',
    'location': 'first'
}).reset_index()

user_interactions = df[df['event_type'].isin(['view', 'cart', 'purchase'])].groupby('user_id').agg({
    'event_type': 'count'
}).reset_index()

user_interactions.rename(columns={'event_type': 'total_interactions'}, inplace=True)

user_data = pd.merge(user_profiles, user_interactions, on='user_id')

print(user_data.head())

product_profiles = df.groupby(['brand', 'category', 'product_name']).agg({
    'price': ['mean', 'min', 'max', 'std', 'count']
}).reset_index()

product_profiles.columns = [' '.join(col).strip() for col in product_profiles.columns.values]

product_profiles.rename(columns={
    'price mean': 'avg_price',
    'price min': 'min_price',
    'price max': 'max_price',
    'price std': 'price_std',
    'price count': 'product_count'
}, inplace=True)

print(product_profiles.head())

category_count = df['category'].nunique()

unique_categories = df['category'].unique()

print(f"Category Count: {category_count}")
print("Unique Categories:")
for category in unique_categories:
    print(category)

!pip install scikit-surprise

from surprise import Reader, Dataset, SVD, accuracy
from surprise.model_selection import train_test_split

event_type_mapping = {
    'view': 1,
    'cart': 2,
    'purchase': 3
}

df['event_type_rating'] = df['event_type'].map(event_type_mapping)

reader = Reader(rating_scale=(1, 3))
data = Dataset.load_from_df(df[['user_id', 'product_name', 'event_type_rating']], reader)

trainset, testset = train_test_split(data, test_size=0.2, random_state=42)

model = SVD()

model.fit(trainset)

predictions = model.test(testset)

rmse = accuracy.rmse(predictions)
mae = accuracy.mae(predictions)

print(f'RMSE: {rmse}')
print(f'MAE: {mae}')

def collaborative_filtering_recommendation(user_id, num_recommendations=5):
    all_product_names = df['product_name'].unique()

    interacted_product_names = df[(df['user_id'] == user_id) & (df['event_type'] == 'purchase')]['product_name'].values

    candidate_product_names = [product_name for product_name in all_product_names if product_name not in interacted_product_names]

    user_ratings = [(user_id, product_name, model.predict(user_id, product_name).est) for product_name in candidate_product_names]

    user_ratings.sort(key=lambda x: x[2], reverse=True)

    top_n_recommendations = user_ratings[:num_recommendations]

    return top_n_recommendations

user_id_to_recommend = 520088904
collaborative_recommendations = collaborative_filtering_recommendation(user_id_to_recommend)

print(f"Collaborative Filtering Recommendations for User {user_id_to_recommend}:")
for _, product_name, estimated_rating in collaborative_recommendations:
    print(f"Product Name: {product_name}, Estimated Rating: {estimated_rating}")

rmse_accuracy = 100 - (rmse * 100)
mae_accuracy = 100 - (mae * 100)

print(f'RMSE Accuracy: {rmse_accuracy:.2f}%')
print(f'MAE Accuracy: {mae_accuracy:.2f}%')

from surprise import dump
import os

# Specify the directory and file name for saving the model
model_dir = 'models'
if not os.path.exists(model_dir):
    os.makedirs(model_dir)

svd_model_file = os.path.join(model_dir, 'svd_model.pickle')

# Save the SVD model
dump.dump(svd_model_file, algo=model)
print(f"SVD model saved to {svd_model_file}")

from surprise import Reader, Dataset, NMF, accuracy
from surprise.model_selection import train_test_split

event_type_mapping = {
    'view': 1,
    'cart': 2,
    'purchase': 3
}

df['event_type_rating'] = df['event_type'].map(event_type_mapping)

content_columns = ['user_id', 'product_name', 'event_type_rating', 'brand', 'price', 'category', 'age', 'gender', 'location']

reader = Reader(rating_scale=(1, 3))

def create_custom_dataset(data, reader, columns):
    custom_data = []
    for _, row in data.iterrows():
        custom_data.append((row[columns[0]], row[columns[1]], row[columns[2]]))
    custom_dataset = Dataset.load_from_df(pd.DataFrame(custom_data, columns=['user', 'item', 'rating']), reader)
    return custom_dataset

data = create_custom_dataset(df, reader, content_columns)

trainset, testset = train_test_split(data, test_size=0.2, random_state=42)

content_model = NMF()

content_model.fit(trainset)

content_predictions = content_model.test(testset)

content_rmse = accuracy.rmse(content_predictions)
content_mae = accuracy.mae(content_predictions)

print(f'Content-Based RMSE: {content_rmse:.4f}')
print(f'Content-Based MAE: {content_mae:.4f}')

def content_filtering_recommendation(user_id, num_recommendations=5):
    all_product_names = df['product_name'].unique()
    interacted_product_names = df[(df['user_id'] == user_id) & (df['event_type'] == 'purchase')]['product_name'].values
    candidate_product_names = [product_name for product_name in all_product_names if product_name not in interacted_product_names]
    user_ratings = [(user_id, product_name, content_model.predict(user_id, product_name).est) for product_name in candidate_product_names]
    user_ratings.sort(key=lambda x: x[2], reverse=True)
    top_n_recommendations = user_ratings[:num_recommendations]
    return top_n_recommendations

user_id_to_recommend = 520088904
content_recommendations = content_filtering_recommendation(user_id_to_recommend)

print(f"Content-Based Recommendations for User {user_id_to_recommend}:")
for _, product_name, estimated_rating in content_recommendations:
    print(f"Product Name: {product_name}, Estimated Rating: {estimated_rating:.4f}")

content_rmse_accuracy = 100 - (content_rmse * 100)
content_mae_accuracy = 100 - (content_mae * 100)

print(f'Content-Based RMSE Accuracy: {content_rmse_accuracy:.2f}%')
print(f'Content-Based MAE Accuracy: {content_mae_accuracy:.2f}%')

nmf_model_file = os.path.join(model_dir, 'nmf_model.pickle')

# Save the NMF model
dump.dump(nmf_model_file, algo=content_model)
print(f"NMF model saved to {nmf_model_file}")

# Combine and prioritize recommendations (example: merge and sort)
def hybrid_recommendation(user_id, num_recommendations=5):
    collaborative_recommendations = collaborative_filtering_recommendation(user_id, num_recommendations)
    content_recommendations = content_filtering_recommendation(user_id, num_recommendations)

    hybrid_recommendations = sorted(collaborative_recommendations + content_recommendations, key=lambda x: x[2], reverse=True)

    return hybrid_recommendations

user_id_to_recommend = 520088904
recommendations = hybrid_recommendation(user_id_to_recommend)

print(f"Hybrid Recommendations for User {user_id_to_recommend}:")
for _, product_name, estimated_rating in recommendations:
    print(f"Product Name: {product_name}, Estimated Rating: {estimated_rating:.4f}")

hybrid_rmse = accuracy.rmse(predictions, verbose=False)
hybrid_mae = accuracy.mae(predictions, verbose=False)

hybrid_rmse_accuracy = 100 - (hybrid_rmse * 100)
hybrid_mae_accuracy = 100 - (hybrid_mae * 100)

print(f'Hybrid RMSE Accuracy: {hybrid_rmse_accuracy:.2f}%')
print(f'Hybrid MAE Accuracy: {hybrid_mae_accuracy:.2f}%')

import matplotlib.pyplot as plt

models = ['Collaborative Filtering', 'Content-Based Filtering', 'Hybrid Model']
rmse_values = [rmse_accuracy, content_rmse_accuracy, hybrid_rmse_accuracy]
mae_values = [mae_accuracy, content_mae_accuracy, hybrid_mae_accuracy]

rmse_values_percentage = [value * 100 for value in rmse_values]
mae_values_percentage = [value * 100 for value in mae_values]

# Create bar plots for RMSE and MAE in percentage
plt.figure(figsize=(10, 5))
bar_width = 0.35
index = range(len(models))
plt.bar(index, rmse_values_percentage, bar_width, color='b', alpha=0.6, label='RMSE')
plt.bar([i + bar_width for i in index], mae_values_percentage, bar_width, color='g', alpha=0.6, label='MAE')
plt.xlabel('Models')
plt.ylabel('Error (%)')
plt.title('RMSE and MAE in Percentage for Different Models')
plt.xticks([i + bar_width / 2 for i in index], models)
plt.legend()
plt.show()

"""#solve cold start problem"""

# Define a function to provide hybrid recommendations for users, considering existing, new users, and new items
def hybrid_recommendation(user_id, num_recommendations=5):
    if user_id in user_data['user_id'].unique():
        collaborative_recommendations = collaborative_filtering_recommendation(user_id, num_recommendations)
        return collaborative_recommendations

    # Check if the user is a new user with demographic data
    if user_id in new_users['user_id'].unique():
        new_user_profile = new_users[new_users['user_id'] == user_id].iloc[0]
        new_user_recommendations = recommend_for_new_user(new_user_profile['age'], new_user_profile['gender'], new_user_profile['location'], num_recommendations)
        return new_user_recommendations

    # New item: Use content-based filtering based on item characteristics
    new_item_profile = new_items[new_items['product_name'] == user_id].iloc[0]
    new_item_recommendations = recommend_for_new_item(new_item_profile['brand'], new_item_profile['category'], new_item_profile['price'], num_recommendations)
    return new_item_recommendations

user_id_to_recommend = 520088904
recommendations = hybrid_recommendation(user_id_to_recommend)

print(f"Hybrid Recommendations for User {user_id_to_recommend}:")
print(recommendations)