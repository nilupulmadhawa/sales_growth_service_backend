# -*- coding: utf-8 -*-
"""research-product-top-recommendation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-URMTbmfAegjmg-ajsZjcUeVJryCW8Xg

Colloborative filtering model
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd

data = pd.read_csv('/content/drive/MyDrive/recommendation/multi-category-dataset-recommendation.csv')
df = data.dropna()

columns_to_keep = ['category_code', 'event_type', 'event_time', 'brand', 'price', 'age', 'gender', 'location']
df = data[columns_to_keep].copy()

split_category = df['category_code'].str.split('.', 1, expand=True)
df['category'] = split_category[0]
df['product_name'] = split_category[1]

df['age'].fillna(df['age'].mean(), inplace=True)

df['event_time'] = pd.to_datetime(df['event_time'], format='%Y-%m-%d %H:%M:%S %Z', utc=True)

print(df.head())

import pandas as pd

# Assuming you don't have a user_id, you can create user profiles based on age, gender, and location.
user_profiles = df.groupby(['age', 'gender', 'location']).agg({
    'event_type': 'count'
}).reset_index()

user_profiles.rename(columns={'event_type': 'total_interactions'}, inplace=True)

print(user_profiles.head())

!pip install scikit-surprise

from surprise import Reader, Dataset, SVD, accuracy
from surprise.model_selection import train_test_split

df['event_type_binary'] = df['event_type'].map({'view': 1, 'cart': 2, 'purchase': 3})
df['pseudo_user_id'] = pd.factorize(df['product_name'])[0]

reader = Reader(rating_scale=(1, 3))  # The rating scale now accurately reflects our event type mapping
data = Dataset.load_from_df(df[['pseudo_user_id', 'product_name', 'event_type_binary']], reader)

trainset, testset = train_test_split(data, test_size=0.2, random_state=42)

model = SVD()
model.fit(trainset)

predictions = model.test(testset)

# Recommendation function adapted for the scenario without using user IDs
def collaborative_filtering_recommendation(num_recommendations=5):
    # Calculate the average rating for each product
    average_ratings = df.groupby('product_name')['event_type_binary'].mean().reset_index()

    # Sort the products by their average rating in descending order
    top_rated_products = average_ratings.sort_values(by='event_type_binary', ascending=False).head(num_recommendations)

    # Return the top N recommended products
    return top_rated_products

# Get top recommended products
top_recommendations = collaborative_filtering_recommendation()

# Display the top recommended products
print("Top Recommended Products:")
for index, row in top_recommendations.iterrows():
    print(f"Product Name: {row['product_name']}, Average Rating: {row['event_type_binary']}")

rmse = accuracy.rmse(predictions)
mae = accuracy.mae(predictions)

# Print evaluation results
print(f'RMSE: {rmse}')  # Root Mean Square Error
print(f'MAE: {mae}')  # Mean Absolute Error

rmse_accuracy = 100 - (rmse * 100)
mae_accuracy = 100 - (mae * 100)

# Print the accuracy results as percentages
print(f'RMSE Accuracy: {rmse_accuracy:.2f}%')
print(f'MAE Accuracy: {mae_accuracy:.2f}%')

import pickle

# Save the model
with open('collaborative_model.pkl', 'wb') as file:
    pickle.dump(model, file)

print("Model saved successfully.")

"""Content Based Model"""

df['product_profile'] = df.apply(lambda x: f"{x['brand']}_{x['category']}_{x['product_name']}", axis=1)

df['user_profile'] = df.apply(lambda x: f"{x['age']}_{x['gender']}_{x['location']}", axis=1)

event_type_mapping = {
    'view': 1,
    'cart': 2,
    'purchase': 3
}
df['event_type_rating'] = df['event_type'].map(event_type_mapping)

reader = Reader(rating_scale=(1, 3))
data = Dataset.load_from_df(df[['user_profile', 'product_profile', 'event_type_rating']], reader)

trainset, testset = train_test_split(data, test_size=0.2, random_state=42)

from surprise import Reader, Dataset, NMF, accuracy

content_model = NMF()
content_model.fit(trainset)

# Making predictions
predictions = content_model.test(testset)

# Evaluation
rmse = accuracy.rmse(predictions)
mae = accuracy.mae(predictions)

print(f'RMSE: {rmse:.4f}, MAE: {mae:.4f}')

# Recommendation function adapted for user profiles and product profiles
def recommend_for_profile(user_profile, num_recommendations=5):
    unique_product_profiles = df['product_profile'].unique()
    predictions = [model.predict(user_profile, product_profile).est for product_profile in unique_product_profiles]
    recommendations = sorted(zip(unique_product_profiles, predictions), key=lambda x: x[1], reverse=True)[:num_recommendations]
    return recommendations

# Example usage
recommendations = recommend_for_profile("25_M_NewYork", 5)
print("Top 5 Recommendations:")
for product_profile, score in recommendations:
    print(f"{product_profile}: {score:.4f}")

import pickle

# Save the model
with open('content_model.pkl', 'wb') as file:
    pickle.dump(content_model, file)

print("Model saved successfully.")